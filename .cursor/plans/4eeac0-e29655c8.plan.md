<!-- e29655c8-a479-47f3-9781-9bbf63b022b0 4ff96f3f-3432-4fe6-8d4d-96e3583381e7 -->
# 计划：实现方块染色系统

为了实现草方块顶部的动态染色，我将对渲染管线的多个部分进行修改，从数据准备（CPU端）到最终着色（GPU端）。

## 实施步骤

### 1. 扩展顶点数据和 `Mesh` 类

染色需要在每个顶点上进行控制。因此，我需要向顶点数据中添加一个新属性：一个浮点数，`1.0` 代表“需要染色”，`0.0` 代表“不需要”。

- **`src/main/java/com/ksptool/mycraft/rendering/Mesh.java`**
- 我将修改 `Mesh` 类的构造函数，让它接受一个新的 `float[] tints` 数组。
- 我会更新顶点缓冲对象（VBO）的布局，将这个新的 `tints` 数据添加进去。
- 我会设置第三个顶点属性（`location = 2`），以便顶点着色器可以访问它。

### 2. 更新 `Chunk` 的网格生成逻辑

现在 `Mesh` 类可以接受染色数据了，我需要修改区块网格的生成逻辑来提供这些数据。

- **`src/main/java/com/ksptool/mycraft/world/Chunk.java`**
- 在 `generateMesh` 方法中，我会创建一个新的 `List<Float> tints`。
- 当为 **草方块的顶面** 添加顶点时，我会向 `tints` 列表中添加 `1.0f`。
- 对于所有其他方块和面，我会添加 `0.0f`。
- 最后，在创建 `Mesh` 对象时，我会将这个 `tints` 列表转换成数组并传递给构造函数。

### 3. 更新着色器 (GLSL)

这是实现染色的核心。我将同时修改顶点和片段着色器。

- **`src/main/resources/shaders/vertex.glsl`**
- 我会添加一个新的顶点属性 `in float a_ShouldTint;` (at `location = 2`)。
- 我会定义一个 `out float v_ShouldTint;`，将这个属性直接传递给片段着色器。

- **`src/main/resources/shaders/fragment.glsl`**
- 我会添加 `in float v_ShouldTint;` 来接收来自顶点着色器的数据。
- 我会添加一个新的 `uniform vec3 u_TintColor;` 来接收从Java代码传入的颜色。
- 在 `main` 函数中，我会检查 `v_ShouldTint` 的值。如果它大于 `0.5`，我就会将采样出的纹理颜色与 `u_TintColor` 相乘。否则，我将使用原始的纹理颜色。

### 4. 更新 `ShaderProgram` 和 `Renderer`

最后，我需要在Java代码中把硬编码的颜色传递给着色器。

- **`src/main/java/com/ksptool/mycraft/rendering/ShaderProgram.java`**
- 我会添加一个新的重载方法 `setUniform(String name, Vector3f value)`，它内部使用 `glUniform3f` 来设置 `vec3` 类型的 uniform 变量。

- **`src/main/java/com/ksptool/mycraft/rendering/Renderer.java`**
- 在 `render` 方法中，调用 `world.render(shader)` 之前，我会调用 `shader.setUniform("u_TintColor", new Vector3f(0.3f, 0.8f, 0.2f));` 来设置全局的草地染色颜色。

这个计划将以一种可扩展的方式，精确地只对草方块的顶面进行染色，同时保持其他方块纹理不变，完美达成您的要求。

### To-dos

- [ ] 扩展 `Mesh.java` 以支持“染色”顶点属性。
- [ ] 更新 `Chunk.java` 的网格生成逻辑以提供染色数据。
- [ ] 修改顶点和片段着色器以执行条件染色。
- [ ] 在 `ShaderProgram.java` 和 `Renderer.java` 中设置染色颜色 uniform。