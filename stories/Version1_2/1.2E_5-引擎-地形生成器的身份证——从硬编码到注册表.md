# 1.2E_5 研发日志：地形生成器的身份证——从硬编码到注册表

大家好，

在完成了数据存储架构的升级后，我们将目光转向了另一个一直被"临时安置"的核心组件——**地形生成器（Terrain Generator）**。

在 1.1Q 版本中，我们曾为地形生成系统引入了分层管道（Layer Pipeline）的概念，让生成逻辑变得可扩展。但当我们回过头审视这套系统时，却发现了一个尴尬的事实：**它不知道自己应该属于谁。**

## 一、失落的地形生成器

想象一下这样的场景：你拥有一个能够生成地球般壮丽地貌的生成器，也许未来还想加入一个平坦世界生成器、一个漂浮岛生成器，甚至一个地狱维度生成器。但现在，所有的世界——无论是什么类型——都被强制使用同一套生成逻辑。

这就像一家餐厅只有一道菜，无论你点什么，端上来的都是同样的东西。

更糟糕的是，这个生成器的"户口"还登记在了服务端专属的代码包里。这意味着客户端无法理解它，共享层无法引用它。它像一个流浪汉，被临时安置在了一个本不该属于它的角落。

## 二、世界模板的困惑

与此同时，我们的 `WorldTemplate`（世界模板）系统也陷入了一种身份危机。它知道世界应该有多高、重力是多少、天空是什么颜色，却不知道**地形该如何生成**。

这就好比一位建筑师拿着设计图纸，上面写满了"大楼应该有 50 层，外墙应该是玻璃幕墙"，却在关键的地方空着一栏：**"施工队：待定"**。

当服务端世界尝试根据模板创建世界时，它只能无奈地硬编码："不管你是什么模板，我都给你用这一套生成器。" 这种做法在原型阶段尚可接受，但当我们规划多维度、多世界类型时，这堵墙就成了必须拆除的障碍。

## 三、解决方案：给生成器发"身份证"

这次重构的核心思想非常简单：**让地形生成器成为引擎的"一等公民"**。

我们要做的，是给每一个地形生成器发放一张独一无二的"身份证"——也就是标准注册名（StdRegName）。有了这张身份证，生成器就可以在注册表里"登记户口"，世界模板也可以通过身份证号来"指定"自己想要的生成器。

### **从硬编码到数据驱动**

**过去的做法：**

```
ServerWorld 初始化 → 直接 new 一个 TerrainPipeline → 硬编码添加各种 Layer
```

这种做法意味着，如果我想创建一个不同的世界，只能去改源码。

**现在的做法：**

```
WorldTemplate 指定生成器 ID → Registry 查询对应的生成器实例 → ServerWorld 使用它
```

这是一个典型的"数据驱动"转变。世界模板只需要说："我要 'ourcraft:terrain_generator:earth_like'（类地球生成器）"，剩下的事情由注册表自动完成。

## 四、架构的三次升级

### **升级一：接口下沉到共享层**

我们将地形生成器的接口定义从服务端专属的代码包迁移到了 `sharedcore`（共享核心）层。这意味着客户端、服务端都能"看见"这些接口，也为未来的单人游戏模式（客户端本地生成）铺平了道路。

关键的接口包括：

- **TerrainGenerator**：生成器的顶层接口，定义了"如何生成一个区块"。
- **TerrainLayer**：地形层接口，每一层负责一种特定的地形特征（如地表、水体、矿脉）。
- **TerrainNoiseGenerator**：噪声生成器接口，为地形提供随机但连续的噪声数据。

通过这种抽象，我们成功地将"定义"与"实现"分离。共享层只定义规则，具体的实现仍然在服务端，这既保持了架构的清晰性，又避免了客户端被迫加载服务端逻辑。

### **升级二：注册表纳管**

地形生成器现在被正式纳入了注册表系统。这意味着它与方块、物品、实体享有同等的地位。

在引擎启动时，我们会注册一个默认的类地球生成器：

```
注册: ourcraft:terrain_generator:earth_like
    ├─ 基础密度层 (生成石头与空气的基本形状)
    ├─ 水体层 (在低洼处填充水)
    ├─ 地表层 (将顶部的石头替换为草方块)
    └─ 特征层 (生成树木、花草等装饰)
```

未来，如果我们想添加一个"超平坦世界"，只需要：

1. 实现一个新的 `FlatTerrainGenerator`。
2. 在启动时注册它。
3. 在世界模板中指定使用它。

完全不需要修改任何现有代码。这就是注册表系统的魅力——它让引擎变得像"乐高积木"一样可扩展。

### **升级三：世界模板绑定**

世界模板现在增加了一个新的字段：`terrainGenerator`。它存储的不是生成器对象本身，而是生成器的注册 ID（一个字符串）。

例如，`WorldTemplateEarthLike`（类地球模板）会声明：

```
terrainGenerator = "ourcraft:terrain_generator:earth_like"
```

当服务端根据这个模板创建世界时，它会：

1. 读取模板中的生成器 ID。
2. 从注册表中查询对应的生成器实例。
3. 如果找不到，抛出异常并明确告诉开发者："缺少生成器：XXX"。

这种"延迟绑定"的设计非常重要。它确保了数据与逻辑的分离，也让 Mod 开发者可以轻松替换或扩展生成器。

## 五、原版内容注册的"搬家"

在这次重构中，我们还顺带解决了一个代码组织问题。

之前，所有的"原版内容注册"（注册默认方块、默认世界模板、默认生成器）都混杂在注册表类本身的静态代码块里。这导致注册表变成了一个"杂货铺"，既管理数据，又自己往里塞东西。

现在，我们将这部分逻辑"搬家"到了实际使用它们的地方：

- **服务端**在启动时调用 `registerAllDefaultContent()`，注册所有引擎自带的内容。
- **客户端**在初始化时也执行相同的注册流程（为单人游戏做准备）。

注册表本身回归了它的本职工作：**只管存储和查询，不管内容从哪来**。

## 六、未来的可能性

有了这套架构，我们可以轻松实现许多之前"想都不敢想"的功能：

### **超平坦世界**

一个只有 4 层方块的平坦世界，用于建筑测试。只需实现一个新的生成器，让它在 Y=0-3 填充基岩和泥土即可。

### **虚空世界**

一个没有任何地形的空白维度，用于空岛生存。生成器完全不生成任何方块，玩家需要在漂浮的小岛上求生。

### **自定义维度**

Mod 开发者可以注册自己的生成器（比如"蘑菇森林""水晶洞穴"），并创建对应的世界模板。引擎会自动识别并使用它们。

### **热重载生成器**

在调试阶段，我们可以支持"不重启服务器，直接切换生成器"的功能。这对于地形设计师来说是巨大的生产力提升。

## 七、一次"看不见"的革命

这次重构没有带来任何视觉上的变化。玩家进入游戏后，看到的世界和之前一模一样——山川、河流、树木，一切如常。

但在代码的深处，一场静悄悄的革命已经完成。地形生成器从"流浪汉"变成了"持证上岗"的引擎组件，世界模板从"困惑的建筑师"变成了"明确的指挥官"。

这是一次架构层面的"松绑"。我们拆掉了硬编码的枷锁，换上了数据驱动的翅膀。虽然现在只有一种地形类型，但未来的无限可能性，已经在今天埋下了种子。

感谢大家的支持，让我们继续建设这个世界。
