# 1.2E_7-引擎-统一坐标系组件(Pos,ChunkPos,LocalPos,ScaPos)

## 坐标系的混乱时代

在之前的开发过程中，我们发现了一个隐蔽但致命的问题：**坐标系定义的混乱**。

在游戏引擎的各个子系统中，坐标的表示方式五花八门：
- 物理系统使用 `Vector3f`（浮点数）表示世界坐标。
- 区块系统使用 `int` 表示区块坐标，但有时又直接用 `long` 类型的 Key 来存储。
- 存档系统（SCA）有一套自己的区域坐标计算逻辑。
- 渲染系统在计算局部坐标时，经常随手写出 `x % 16` 这样的代码。

这种混乱导致了几个严重后果：
1. **负数坐标地狱**：Java 的整数除法在处理负数时是向零取整（例如 `-5 / 16 = 0`），而游戏世界通常需要向下取整（期望 `-1`）。这导致了出生点（0,0）附近的负数象限经常出现坐标计算错误（著名的“第0区块重复”bug）。
2. **魔法数字泛滥**：到处都是 `16`、`40`、`SHIFT` 运算，一旦将来想要调整区块大小（例如改为 32x32x32），将是一场灾难。
3. **类型安全缺失**：一个 `int x` 传进来，你不知道它是世界坐标、区块坐标还是局部坐标，极易混淆。

## 统一坐标系组件

为了彻底解决这些问题，我们引入了一套类型安全的坐标系组件，将坐标的概念对象化、职责明确化。

### 1. 核心组件设计

我们定义了四个核心坐标类，分别对应不同的业务场景：

*   **`Pos` (世界坐标)**
    *   **定义**：表示游戏世界中的绝对整型坐标 (x, y, z)。
    *   **职责**：作为一切转换的源头，负责向其他坐标系转换。
    *   **特性**：封装了 `Math.floor` 逻辑，确保从浮点数转换时的精度正确。

*   **`ChunkPos` (区块坐标)**
    *   **定义**：表示方块所在的区块网格坐标 (cx, cy, cz)。
    *   **职责**：用于区块索引、加载队列和内存管理。
    *   **特性**：是世界分块的基础单位。

*   **`LocalPos` (局部坐标)**
    *   **定义**：表示方块在区块内部的相对坐标 (lx, ly, lz)。
    *   **职责**：用于读取区块数据数组、渲染网格构建。
    *   **特性**：范围严格限制在 `[0, chunkSize-1]`，消除了负数。

*   **`ScaPos` (SCA归档坐标)**
    *   **定义**：表示区块所属的归档文件（.sca）索引。
    *   **职责**：用于大地图存储、磁盘IO寻址。
    *   **特性**：封装了 40x40 (SCAF_CHUNK_SIZE) 的超级区块聚合逻辑。

### 2. 标准化的转换管线

我们废弃了散落在代码各处的位运算和除法，将其封装为标准转换方法。

**世界坐标 -> 区块坐标/局部坐标**
```java
// 旧代码（容易出错）
int chunkX = x >> 4; 
int localX = x & 15; // 仅对2的幂次有效

// 新代码（清晰、通用）
ChunkPos chunkPos = worldPos.toChunkPos(chunkSizeX, chunkSizeZ);
LocalPos chunkLocalPos = worldPos.toLocalPos(chunkSizeX, chunkSizeZ);
```

**核心算法改进**：
我们在底层统一使用了数学上严谨的转换公式，彻底修复了负数边界问题：
```java
// 区块坐标计算原理：向下取整
int chunkX = (int) Math.floor((double) x / chunkSizeX);

// 局部坐标计算原理：世界坐标 - 区块原点
int localX = x - chunkX * chunkSizeX;
```
这个公式保证了无论正负，局部坐标永远是正数且连续的。

**世界坐标/区块坐标 -> SCA坐标**
SCA 系统的坐标转换逻辑也被统一封装：
```java
// 支持从世界坐标直接计算，也支持从区块坐标计算
ScaPos scaPos = chunkPos.toScaPos(SCAF_PKG_SIZE);
```

### 3. 参数化与可扩展性

在新的设计中，所有的转换方法都要求显式传入 `chunkSize` 或 `scaPkgSize`。
```java
public ChunkPos toChunkPos(int chunkSizeX, int chunkSizeZ) { ... }
```
这看似繁琐，实则为了未来的扩展性留出了巨大空间。通过将“区块大小”作为参数而非硬编码常量，我们解耦了坐标逻辑与配置数据。这意味着理论上我们可以在同一个服务器中运行不同区块大小的世界，或者轻松修改全局配置而无需重构底层数学库。

## 总结

这次重构虽然代码量不大，但属于极其重要的“基础设施建设”。
通过引入 `Pos`、`ChunkPos`、`LocalPos` 和 `ScaPos`，我们：
1.  **消除了坐标混淆**：利用 Java 的类型系统防止传错参数。
2.  **统一了算法真理**：所有坐标转换逻辑收敛到一处，Bug 无处遁形。
3.  **奠定了稳固基石**：为接下来的物理引擎重构和无限地图生成提供了可靠的数学工具。

从此，我们不再关心 `x >> 4` 还是 `x / 16`，我们只关心 `Pos`。

