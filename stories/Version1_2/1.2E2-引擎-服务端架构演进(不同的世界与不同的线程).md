# 1.2E_2 研发日志：不同的世界与不同的线程

随着我们的世界逐渐变得丰富，承载这一切的服务器核心也开始显露出疲态。在过去的设计中，`OurCraftServerInstance` 就像一位不知疲倦的管家，事无巨细地操持着一切：从监听网络端口、接待新玩家，到计算每一块方块的物理碰撞、模拟世界的每一次心跳。

这种“全能”的设计在初期确实简单直接，但随着功能的增加，这位管家变得越来越不堪重负。它不仅要时刻关注门外的敲门声（网络请求），还要同时在屋内指挥所有家具的摆放（游戏逻辑）。这种职责的混杂不仅让代码变得臃肿难懂，也让我们在面对未来可能的多世界（Multi-world）需求时显得束手无策。

因此，在这个版本中，我们决定让这位管家“卸下重担”，进行一次彻底的职责拆分。

我们引入了 **ServerWorldExecutionUnit（世界执行单元）** 的概念。你可以把它想象成一个个独立运作的“微型宇宙”。现在，原本混杂在服务器实例中的游戏循环、物理模拟和实体更新逻辑，都被封装进了这个独立的单元中。每个世界都拥有了自己的心跳，它们在各自的轨道上独立运行，互不干扰。这意味着，未来我们可以轻松地让主世界、下界甚至更多奇异的维度并行运转，充分利用现代处理器的多核性能。

为了管理这些独立的宇宙，我们设立了 **ServerWorldManager（世界管理器）**。它就像是一位高层的调度员，负责世界的创建、加载、启动和销毁。它不关心世界内部的具体运作，只专注于生命周期的维护，确保每个世界都能在正确的时间诞生和消亡。

而原本那位忙碌的 `OurCraftServerInstance`，现在终于可以回归它的本职工作了。它不再亲自下场参与世界的模拟，而是专注于成为一座稳固的桥梁——连接着外部的玩家与内部的游戏世界。它负责监听网络、处理握手、将玩家的请求分发给正确的管理器，成为真正的“服务器容器”和“网络网关”。

在这次重构中，我们也顺带解决了一些因架构变动而引发的有趣挑战。比如，我们发现将玩家的输入（如移动指令）直接应用到实体上在多线程环境下是不安全的。于是，我们引入了事件队列机制，让玩家的操作变成一个个待处理的“事件”，由世界执行单元在每一帧的开始统一处理。这不仅解决了线程安全问题，也让逻辑流向变得更加清晰。

虽然这次改动并没有带来直观的新玩法，但它为我们的代码库卸下了沉重的包袱。现在的架构更加轻盈、清晰，也更具扩展性。虽然网络部分目前仍暂时寄宿在主实例中，但在未来的计划里，它也将迎来属于自己的独立时刻。

这是一次必要的“深呼吸”，为了让我们的世界能跑得更远、更稳。
