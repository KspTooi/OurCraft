# **研发日志：实体架构重构——从“继承”走向“组合” (ECS)**

大家好，  
在上一篇日志（1.2B/C）中，我们确立了统一注册表（Registry）的架构，并计划将所有游戏内容标准化为“模板（Template）”与“实例（Instance）”的分离模式。对于**方块**和**物品**而言，这种模式依然完美适用。  
**但是，对于“实体（Entity）”——即游戏中的玩家、生物、掉落物等——我们决定推翻之前基于继承的设计方案。**  
经过深入的原型测试，我们意识到传统的“继承式模板”在处理复杂的生物行为时显得过于僵化，容易导致代码膨胀。因此，我们决定引入现代游戏开发中备受推崇的架构：**实体组件系统 (ECS, Entity-Component System)**。

### **面向开发者 (Developer)**

这是本次重构的核心。在早期的设计设想中，我们原本打算像定义方块一样，通过继承 EntityTemplate 或 ServerLivingEntity 来定义新的生物。但这不可避免地引入了“上帝类（God Class）”问题——基类承载了太多它不该有的逻辑。  
**ECS 带来的根本性改变：**

1. **抛弃继承 (No More Inheritance):**  
   * **旧设计：** 要做一个僵尸，你需要写 class Zombie extends Monster extends LivingEntity。如果你想让一个箱子拥有血条，你必须让箱子继承 LivingEntity，但这会让箱子“学会”走路，这显然不合理。  
   * **新设计 (ECS)：** **组合优于继承**。实体 (GameEntity) 仅仅是一个空容器（一个 UUID）。通过向容器中放入不同的“组件 (Component)”，它就变成了不同的东西。  
2. **数据与逻辑分离 (Data & Logic Separation):**  
   * **Component (组件):** 只存数据，不存逻辑。  
     * 例如：HealthComponent (存血量), PhysicsComponent (存速度), InputComponent (存意图)。  
   * **Processor/System (处理器):** 只写逻辑，不存数据。  
     * 例如：EntityMovementProcessor 会遍历所有拥有“移动组件”的实体并计算位置；EntityPhysicsProcessor 负责处理重力与碰撞。  
3. **重新定义“注册” (Redefining Registration):**  
   * 在 Registry 中，我们注册的不再是一个僵尸的**类**，而是一个**配方 (Factory/Recipe)**。  
   * 当游戏生成一个“僵尸”时，它实际上是执行了一行指令：“创建一个空实体，给它装上 外观组件、物理组件 和 AI组件”。

这种架构极大地降低了模块间的耦合度，彻底解决了 ServerLivingEntity 随着功能增加而无限膨胀的问题。

### **面向用户 (User)**

虽然您不会直接看到代码，但 ECS 架构将为您带来肉眼可见的游戏体验提升，特别是在未来的更新和 Mod 支持方面。

* **无限的可能性：**  
  * 因为我们不再受限于“生物必须是生物”的硬性分类，我们可以轻松创造出以前很难实现的内容。  
  * 想做一个\*\*“长着腿跑来跑去的宝箱”\*\*？以前这很难编写，现在只需要给宝箱加上“移动组件”和“AI组件”即可。  
  * 想做一个\*\*“拥有血条且可以被破坏的木门”\*\*？只需要给门加上“生命组件”。  
* **性能优化：**  
  * ECS 允许游戏引擎更聪明地处理数据。例如，游戏不再需要计算一块“静态石头”的移动逻辑，因为它根本就没有“物理组件”。这意味着我们可以用同样的电脑性能，支持更多数量的实体。  
* **更快的更新速度：**  
  * 由于开发者不需要在复杂的代码迷宫中寻找逻辑，添加新生物和新特性的速度将大幅提升。

### **总结**

虽然这推翻了我们在 1.2B 中对实体的部分设想，但这是一次必要的进化。我们保留了注册表（Registry）来统一管理 ID，但对于实体，我们从“填写表格（Template）”进化到了“搭积木（Component）”。  
这是构建一个真正自由、高效的沙盒世界的基石。