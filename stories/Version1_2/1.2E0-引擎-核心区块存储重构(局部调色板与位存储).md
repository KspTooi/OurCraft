# **研发日志 1.2E：核心存储重构——调色板与位存储 (Paletted Storage)**

大家好，  
在之前的日志（1.2D）中，我们成功重构了**实体系统（ECS）**，解决了游戏逻辑层面的耦合问题。今天，我们转向引擎的另一个核心命脉：**数据存储与内存管理**。  
为了实现我们预想中的目标，我们必须解决一个显而易见的瓶颈：**现有的区块存储方式太奢侈了。**  
经过团队的深入研发，我们正式引入了现代体素引擎的标准存储方案：**局部调色板（Local Palette）与位存储（Bit Storage）**。

### **我们面临的问题：内存黑洞**

在此之前，我们的 ChunkData 使用最朴素的方式存储方块：一个巨大的三维整数数组 int\[\]\[\]\[\]。

* **每个方块占用**：4 字节（32位）。  
* **一个标准区块 (16x256x16)**：需要 65,536 个整数。  
* **总内存占用**：**256 KB** / 区块。

听起来不多？但如果我们想实现 **32 区块视距**（加载 4000+ 个区块），仅存储“哪里是什么方块”这一项数据，就需要 **1 GB** 的内存！这还没算网格数据、实体数据和 Java 对象头开销。  
这种“粗放”的存储方式是我们性能优化的最大拦路虎。

### **解决方案：调色板压缩 (Paletted Storage)**

我们引入了两个全新的核心类：ChunkBlockData 和 BitStorage，它们彻底改变了数据的存储方式。

#### **1\. 核心思想：局部调色板 (Local Palette)**

我们发现，虽然游戏里可能有几千种方块（全局 ID），但在一个具体的区块内，通常只会用到 10\~50 种方块。  
既然只有 50 种方块，为什么我们要用能表示 40 亿种可能性的 32位整数去存它呢？

* **旧方案**：直接存全局 ID（比如 1203, 452, 88...）。  
* **新方案**：  
  1. 建立一个\*\*“局部清单” (Palette)\*\*：\[0:空气, 1:石头, 2:泥土, 3:草方块...\]  
  2. 在数组里只存**清单的下标**（Local ID）：\[1, 1, 2, 3, 0...\]

#### **2\. 核心技术：位存储 (BitStorage)**

如果局部清单里只有 16 种方块，我们只需要 4个比特位 (4-bit) 就能表示它们（$2^4=16$）。  
于是，我们开发了 BitStorage 类。它是一个极其紧凑的容器，能将这些微小的 4-bit 数据像沙丁鱼一样挤进 Java 的 long（64位）数组中。

* **效果**：  
  * 原来存 1 个方块需要 **32位**。  
  * 现在存 1 个方块可能只需要 **4位**。  
  * **内存占用降低了 87.5%！**

一个原本占用 256KB 的区块，现在可能只需要 **20KB**。这意味着同样的内存，我们可以加载 **8 倍** 大小的世界区域！

### **技术细节：动态扩容**

我们的 ChunkBlockData 极其智能。它不是固定大小的，而是会根据内容的复杂程度**动态生长**：

1. **初始状态**：区块刚创建时可能是空的，或者是纯海洋。此时它只占用极少的位数（例如 4-bit）。  
2. **自动扩容**：当玩家在一个简单的区块里放置了第 17 种不同的方块时，调色板会自动检测到 4-bit 装不下了，于是它会瞬间将底层存储扩容到 5-bit，并无缝迁移数据。

这一切对上层逻辑（如物理引擎、建筑系统）都是透明的。你只需要调用 setBlock()，剩下的脏活累活底层全包了。

### **关键决策：ECS 实装推迟与空间索引**

在推进 ECS (实体组件系统) 的过程中，我们做出了一个重要的架构决策：**暂时推迟 ECS 的全面实装，优先解决区块与实体的空间关系问题。**  
目前的网络同步是“全服广播”的——即任何实体的移动都会发送给服务器上的所有玩家。这在玩家数量较少时是可行的，但在大规模多人游戏中会导致网络带宽瞬间爆炸。  
**我们要解决的核心问题：**

* **实体在哪里？** 我们需要知道每个区块里包含哪些实体（Block \-\> Entity）。  
* **谁在看？** 我们需要知道每个区块被哪些玩家加载/关注了（Chunk \-\> Player）。

**新的实施计划：**

1. **Chunk-Based Entity Storage**: 在 ServerChunk 中维护一个实体列表。当实体移动跨越区块边界时，自动更新这个列表。  
2. **Entity Tracker**: 建立一个追踪系统。当实体在某个区块内发生变化（移动、生成、销毁）时，**只** 向那些“正在看着这个区块”的玩家发送网络包，而不是全服广播。

这不仅是 ECS 的前提，也是整个多人游戏性能的基石。只有打通了“空间索引”这一关，ECS 的优势才能真正发挥出来。

### **下一步计划**

随着 ChunkBlockData 和 BitStorage 的就位，我们接下来的工作重心将转移到集成与存档重构：

1. **开发 ServerChunkManager**：这是一个全新的服务端区块管理器，它将使用新的存储结构来管理世界数据，**并集成即将到来的空间索引逻辑**。  
2. **重构 SCA 存档系统**：  
   * 既然内存中的数据已经是压缩过的了，我们不再需要旧的 RLE（游程编码）算法。  
   * 新的保存逻辑将非常简单粗暴：直接把 BitStorage 的 long\[\] 数组和调色板列表写进磁盘。这不仅文件更小，而且**读写速度将会有数量级的提升**。  
3. **网络优化**：利用同样的数据结构，我们将大幅减少服务器同步区块给客户端时的网络带宽消耗。

这是引擎底层架构的一次质的飞跃。感谢大家的支持，让我们向着“无限世界”更进一步！