# **1.2E\_10 研发日志：Flex组件准备与出生机制完善**

大家好，  
在 V1.2E\_8 中，我们完成了区块读写层的统一；在 V1.2E\_9 中，我们移除了散乱的线程池，建立了统一的异步管理机制。  
今天，V1.2E\_10 带来了实装 Flex 系列组件前的最后一块拼图。我们对区块生命周期进行了外科手术式的调整，完善了玩家数据，并让出生机制真正“落地”。  
所有的准备工作都已完成，Flex 组件的实装之路已经畅通无阻。

## **一、玩家数据的最后两块拼图**

我们在 PLAYER\_INDEX 表中补全了两个一直缺失的重要字段：

* **LOGIN\_COUNT**：玩家登录次数。
* **LAST\_LOGIN\_TIME**：最后登录时间。

这看似微小的改动，对于未来的运营统计、活跃度分析以及“欢迎回来”的提示语都至关重要。现在，每一个进入服务器的 PlayerSession都会忠实地记录这些信息。

## **二、不仅是出生，更是安家**

还记得在 1.1X7 版本中，我们曾因服务端竞态条件（Race Condition）导致玩家反复掉入虚空吗？那时我们通过在玩家加入时强制同步生成区块并计算安全高度 findSafeSpawnY 解决了燃眉之急。但那只是一个运行时的“补丁”。  
在 1.2E\_10 中，我们将这一机制升级为了世界级的**持久化特性**。

### **旧版机制 (1.1X7) vs 新版机制 (1.2E\_10)**

* **触发时机**：
    * *旧版*：每次玩家请求加入服务器时计算。
    * *新版*：**世界创建或首次加载时**计算一次，通过 ServerWorld.createDefaultSpawn() 触发。
* **数据存储**：
    * *旧版*：临时计算，不保存，依赖于 Y=64 的硬编码回退。
    * *新版*：写入归档索引数据库 (WORLD\_INDEX 表)，成为世界的永久属性。
* **选址算法**：
    * *旧版*：简单的垂直扫描，只要是非空气方块就算地面，容易出生在树顶或水中。
    * *新版*：**智能宜居性扫描**。引擎会以 (0,0) 为中心，遍历搜索周围的区块，优先寻找 **草方块 (Grass Block)** 表面作为出生点。这意味着玩家将始终出生在适宜生存的平原或林地上，而不是大海中央或悬崖峭壁。

现在的流程是：当一个新世界被初始化时，引擎会自动“勘探”周围地形，找到最完美的落脚点，将其坐标永久写入档案。无论地形生成器如何疯狂，新玩家总能有一个安全、舒适的“家”。

## **三、事件驱动的开端**

最后，我们为服务端引入了一个轻量级的 ServerWorldEventBus。  
虽然它现在还很简陋，基于一个高效的 ConcurrentLinkedQueue，但它是解耦游戏逻辑的关键第一步。未来的成就系统、任务系统、甚至插件系统，都将在这个总线上生长。

## **四、Flex：重新定义区块架构**

在实装之前，我们必须回答一个核心问题：**为什么要抛弃现有的区块系统？**

### **0\. 告别单机时代的遗产**

在早期的引擎版本中，区块组件（ServerChunkOld）带有浓重的单机架构色彩。它设计之初的假设是：世界是同步更新的，内存是无限的，且只有一个玩家（或主线程）在访问数据。  
然而，随着引擎全面转向 **C/S（客户端/服务端）架构**，这些旧时代的假设变成了巨大的技术债务：

* **网络传输低效**：硬编码的 int\[\]\[\]\[\] 数组无法高效序列化，导致带宽浪费。
* **并发灾难**：缺乏细粒度的锁机制，导致多线程（如网络线程、生成线程、逻辑线程）并发读写时频发竞态条件。
* **同步困难**：旧区块不知道“谁在看它”，这让实现高效的按需网络同步变得异常复杂。

为了适应高性能专用服务器的需求，我们必须推倒重来。**Flex 体系**正是为此而生。

### **1\. 动态维度的灵活性 (Arbitrary Dimensions)**

Flex 组件打破了硬编码尺寸的桎梏。它的底层索引计算公式 index \= (y \* layerArea) \+ (z \* width) \+ x 以 Y 轴为主序，这意味着它天生适合处理垂直堆叠的数据。  
无论是标准的 16x16x256，还是扁平的 64x16x64，甚至是未来可能出现的垂直区块（Cubic Chunks），FlexChunkData 都能原生支持。

### **2\. 极致的内存压缩 (Palette-based Compression)**

这是 Flex 最引以为傲的特性。我们引入了 **局部调色板 (Local Palette)** 与 **位存储 (Bit Storage)** 的组合拳：

* **智能映射**：利用 Int2IntOpenHashMap 维护全局 ID 到局部 ID 的映射。如果一个区块只有泥土和石头，局部 ID 只需要 1 bit。
* **动态位宽**：底层的 BitStorage 使用紧凑的 long\[\] 数组存储数据。当方块种类增加时，它会自动将存储位数从 4-bit 扩容至 N-bit。
* **自动碎片整理**：compact() 方法会在后台运行，清理掉调色板中不再使用的方块引用，并尝试降低位宽，确保内存占用始终处于理论最小值。

### **3\. 无锁并发快照 (Lock-Free Snapshots)**

为了彻底根除“渲染线程读取时正好被逻辑线程修改”导致的闪烁或崩坏，Flex 引入了 **写时复制 (COW) 思想的快照机制**。

* createSnapshot() 会瞬间克隆当前的调色板和位存储数据。
* 渲染线程持有的是一个不可变的 Snapshot 对象。它的 getBlock() 方法是**绝对无锁**的，没有任何 synchronized 开销。这意味着网格生成器可以全速运行，绝不阻塞主逻辑线程的写入操作。

### **4\. 感知型生命周期 (Awareness & TTL)**

区块不再是被动的容器，它现在拥有“自我意识”。

* **Watcher 拓扑**：FlexServerChunk 维护了 playersInside 和 playersWatching 两个并发集合。区块数据的变更只会精准推送到关注它的客户端，大幅降低无效带宽消耗。
* **原子化 TTL**：配合 AtomicInteger 实现的 TTL 倒计时机制，让区块在失去玩家关注后平滑进入回收队列，有效消除了区块边界反复加载造成的 IO 颠簸。

### **5\. 原生异步与 CompletableFuture (Native Async)**

Flex 组件生来就是为了配合虚拟线程（Virtual Threads）使用的。得益于 Java 21+ 的虚拟线程，我们终于可以像写同步代码一样写异步逻辑了。

* **告别回调地狱**：FlexServerChunkService 的异步生成接口全面支持 CompletableFuture。网络线程在请求一个未生成的区块时，不再需要编写复杂的回调，也不需要空转等待。它只需持有一个 loadFuture，然后优雅地 join()。虚拟线程会挂起，直到后台生成任务完成。
* **全异步调度**：区块的 IO、反序列化、地形生成被完美封装在后台线程池中。FlexServerChunkService 能够以非阻塞的方式调度成百上千个区块任务，即使在千人同屏的高负载下，TPS 依然稳如磐石。

### **6\. 严谨的状态流转 (Strict Lifecycle States)**

在并发环境下，一个区块到底处于什么状态？这个问题曾经让我们头疼。在引入虚拟线程（VT）和异步 IO 后，旧的简单状态机不再适用了。  
在 V1.2E\_10 中，我们将 FlexServerChunk 的生命周期重构为 5 个核心阶段，配合 CAS（比较并交换）操作，彻底解决了高并发下的状态竞争问题：

* **NEW**：区块对象刚被创建，一张白纸。
* **PROCESSING\_LOAD**：正在加载中。这是一个关键的“保护状态”，防止多个线程同时触发同一个区块的 IO 或生成任务。
* **READY**：数据已就绪。此时区块完全可用，可以进行读写和物理交互。
* **PROCESSING\_UNLOAD**：正在卸载中。同样是一个保护状态，防止在存盘过程中被重复卸载，同时允许在最后关头被“抢救”回来（如果玩家突然返回）。
* **INVALID**：彻底失效。区块已从内存移除，任何残留引用都应抛弃。

## **五、从 Manager 到 Service：命名的哲学**

细心的开发者可能已经发现，在这个版本中，我们悄悄地完成了一次大规模的重命名重构。

我们将所有的 `Manager`（管理器）重命名为了 `Service`（服务）。例如 `FlexServerChunkManager` 变成了 `FlexServerChunkService`，`ServerWorldManager` 变成了 `ServerWorldService`，`ServerPlayerManager` 变成了 `ServerPlayerService`。

这不仅仅是名字的改变，更是设计理念的转变：

*   **Manager** 往往暗示着“管理”，侧重于对内部资源的 CRUD（增删改查）和生命周期控制，通常是重量级的、有状态的。
*   **Service** 则强调“服务”，侧重于向外部提供功能接口，通常是无状态的（或状态透明的）、轻量级的组件。

这次更名标志着我们的架构进一步向 **面向服务架构 (SOA)** 靠拢。未来的系统模块将通过清晰定义的 Service 接口进行交互，而不是直接操作对方的内部状态。这会让代码耦合度更低，测试更容易。

## **六、Session 与雪花算法：更专业的连接管理**

在网络层，我们做出了两个重要的架构升级：

*   **引入 `PlayerSession` (玩家会话)**：以前的网络连接只是一层薄薄的 Wrapper，现在升级为拥有完整生命周期的 Session 对象。它负责维护连接状态、心跳检测（KeepAlive）以及玩家从 `NEW` -> `PROCESSING_DATA` -> `READY` 的登录状态流转。
*   **实装雪花算法 (Snowflake ID)**：将会话 ID 的生成机制从简单的自增 ID 升级为 Twitter 的 **雪花算法**。这意味着每个会话都有一个全局唯一、时间有序且不依赖数据库的 64 位 ID。

## **下一步：Flex 实装**

扫清了线程池的障碍，理顺了区块的生命周期，完善了数据的存储，统一了服务的命名。

在下一个版本中，我们将正式在服务端和客户端实装 **Flex 系列区块组件**。这不仅是一次组件替换，更是整个引擎性能和灵活性的质的飞跃。  
感谢大家的支持，让我们继续建设这个世界。
