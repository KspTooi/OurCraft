# **研发日志 1.2F3：服务化架构与基础设施重塑**

大家好，  
如果说 1.2F2 是我们在资源管理上的一次“立规矩”（引入租约系统），那么 1.2F3 就是我们在代码架构上的一次“大扫除”。  
在之前的版本迭代中，为了快速实现功能，我们引入了诸如 ServerWorldService、SimpleEntityService 和 FlexChunkService 等概念。虽然名为“服务”，但它们在运行逻辑上缺乏统一标准，往往需要 ServerWorld 亲自“手把手”地调用它们的各个方法。  
在 1.2F3 中，我们正式确立了 **服务化架构标准**，并对底层基础设施进行了关键升级。

## **一、服务化与 SequenceUpdate：让世界自动运转**

在过去，ServerWorld 的 action 方法（即 Tick 循环）就像一个巨大的面条代码仓库。它需要显式地调用实体更新、区块加载、物理计算等所有逻辑。一旦我们要添加新功能（比如 FlexChunk），就不得不侵入修改 ServerWorld 的核心循环。

### **变革：SequenceUpdate 接口**

为了解耦，我们引入了 **SequenceUpdate** 接口。这是一个标准化的“心跳”协议。  
现在，所有的核心子系统——无论是管理实体的 SimpleEntityService，还是掌管地图的 FlexServerChunkService（尽管 Flex 区块尚未全面实装）——都必须实现这个接口。  
public interface SequenceUpdate {  
    /\*\*  
     \* 执行更新  
     \* @param delta 距离上一帧经过的时间（秒）  
     \* @param world 世界实例  
     \*/  
    void action(double delta, SharedWorld world);  
}

**带来的改变：**

* **ServerWorld 的解放**：现在的 ServerWorld 不再关心具体的业务逻辑。它变成了一个 **调度器**，负责按正确的顺序（Sequence）委托调用各个 Service 的 action 方法。  
* **逻辑内聚**：实体物理计算、跨区块检测等逻辑现在完全封装在 SimpleEntityService 内部；区块的生命周期维护则封装在 Chunk Service 中。各司其职，互不干扰。

## **二、基础设施升级：位置类的身份认证**

我们在 com.ksptool.ourcraft.sharedcore.utils.position 包下对一系列坐标类（Pos, ChunkPos, ScaPos 等）进行了底层升级。

### **实现 hashCode 与 equals**

这听起来是一个很小的改动，但对于服务端性能至关重要。  
在之前，如果我们将 ChunkPos 用作 HashMap 的 Key（例如在区块缓存或租约管理中），由于缺乏这就两个方法，Java 只能依赖对象内存地址来判断相等性。这导致即便两个坐标数值完全一样（比如都是 \[1, 1\]），系统也会把它们当成两个不同的位置。  
现在，所有位置类都正确实现了值语义的相等性判断。这意味着我们可以放心地将坐标用作 Key，极大地提升了 FlexChunkLeaseService 和 WorldExecutors 的查找效率和逻辑正确性。

## **三、事件总线重构：告别 instanceof**

我们的事件系统 WorldEventBus 终于迎来了现代化改造。

### **过去痛点：if \- instanceof 链条**

在旧版本中，处理事件是一场噩梦。我们需要从队列中拉取所有事件，然后写一长串丑陋的 if 语句：  
// 旧代码（伪代码）  
if (event instanceof PlayerInputEvent) { ... }  
else if (event instanceof BlockBreakEvent) { ... }  
else if (event instanceof ... ) { ... }

这不仅效率低下（每次都要进行类型反射检查），而且让代码难以扩展。

### **现在：发布-订阅模式 (Pub-Sub)**

我们重写了 ServerWorldEventBus，实现了真正的**发布-订阅模式**。现在，服务只需要在初始化时“订阅”它感兴趣的事件类型：  
// 新代码风格  
eventBus.subscribe(ServerPlayerInputEvent.class, this::processPlayerInput);  
eventBus.subscribe(ServerPlayerCameraInputEvent.class, this::processPlayerCameraInput);

当事件发生时，EventBus 会直接将事件分发给对应的监听器，无需任何多余的类型检查。这不仅让代码更加优雅，也为未来插件系统的事件监听打下了基础。

## **结语**

1.2F3 是一个“内功修炼”的版本。虽然表面上玩家看到的玩法没有巨变，但引擎内部的齿轮咬合得更加精密了。标准化的服务接口、可靠的基础设施、高效的事件分发，这一切都为承载即将到来的复杂玩法做好了准备。  
感谢大家与我们一同见证 OurCraft 的成长！