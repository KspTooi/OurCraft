# **研发日志 1.2F4：物理基石、时间秩序与 FlexChunk 的漫长征途**

大家好，  
欢迎来到 1.2F4 版本。在这个版本中，我们继续对引擎的底层架构进行大刀阔斧的改革。  
在深入介绍本版本的更新之前，我想先聊聊两个话题：一个是大家已经在代码中见到多次的 **"Action"** 概念，另一个是大家最关心的 **FlexChunk（超级区块系统）** 的实装进度。

## **📖 引擎概念演进：从 "Tick" 到 "Action"**

在阅读源码或日志时，你可能会发现我们频繁使用 **"Action"** 这个词。为了方便新老开发者理解，我们需要梳理一下它的演进历史。

### **历史回顾**

* **Alpha \~ 1.2F1 以前**：我们沿用了传统术语 **"Tick" (逻辑刻)**。那时的逻辑非常简单，仅仅是 while(running) { update(); }，所有的逻辑混杂在一起。  
* **1.2F2 (转折点)**：随着 C/S 架构的引入，我们需要更精确的控制。我们正式引入了 **Action** 概念，并定义了 SequenceUpdate 接口。

### **什么是 Action？**

这个词起源于电影制作术语——导演大喊一声 "Action\!"，演员开始表演，摄影机开始转动，所有的事件在这一刻开始推进。  
在 OurCraft 中，**Action** 代表了一个**原子化的、标准化的逻辑推进单位**。

* 它不仅仅是简单的“循环一次”，而是一套严格定义的**流水线 (Pipeline)**。  
* 在一个 Action 内，时间推进、物理模拟、网络包处理、事件分发必须按照严格的顺序发生。

在 1.2F4 中，我们正是通过将原本混杂在一起的代码，拆解并委托给下面两个全新的“服务”在 Action 中执行，从而实现了逻辑的解耦。

## **一、物理服务：从“被动检测”到“主动模拟”**

在旧版本中，物理逻辑是非常混乱的。实体在移动时会调用一个叫 collisionManager 的工具类，问一句：“我可以走到那儿吗？”（canMoveTo）。这种**被动式**的设计在逻辑简单时够用，但在 C/S 架构下，这导致物理计算的控制权分散在成百上千个实体对象手中，极难维护。

### **核心升级：物理服务 (ServerWorldPhysicsService)**

在 1.2F4 中，我们将旧的碰撞管理器正式晋升为 **物理服务**。

* **标准化接口**：它实现了 SequenceUpdate 接口，正式嵌入了服务端的 Action 循环。这意味着每一帧都有一个专门的阶段来处理物理，而不是混杂在实体的逻辑里。  
* **职责收拢**：  
  * **现在**：它接管了所有的碰撞检测逻辑和射线检测（Raycast）。  
  * **未来**：它是未来物理引擎的基础。我们将逐步把**速度积分**、**重力应用**以及**碰撞响应**从实体类（Entity）中剥离出来，统一交由物理服务进行计算。这意味着未来的实体将只是一堆数据（Component），而物理服务负责让它们动起来——这是通往 ECS (实体-组件-系统) 架构的必经之路。

## **二、时间服务：掌管世界的心跳**

长期以来，游戏世界的“时间”只是 ServerWorld 类里一个孤零零的 long totalTicks 变量，再加上一段散落在世界更新循环里的 \++ 代码。这种简陋的实现不仅耦合度高，而且难以处理复杂的时间需求（如变速、回滚）。

### **新增：时间服务 (ServerWorldTimeService)**

为了解决逻辑散落问题，我们将时间管理逻辑剥离，创建了独立的 **时间服务**。

* **原子化计时**：基于 AtomicLong 维护世界的总 Action 次数，确保在高并发环境下的线程安全。  
* **日夜循环封装**：它封装了将 Action 数转换为游戏内 LocalDateTime 和 24 小时制 TimeOfDay 的逻辑。渲染器现在可以从这个服务获取精确到毫秒的日夜变化参数，实现平滑的昼夜交替。  
* **逻辑解耦**：ServerWorld 不再亲自计算时间，它只需要在 Action 循环中委托时间服务“滴答”一下。这让 ServerWorld 的代码更加干净，专注于调度而非执行。

## **⚠️ 关于 FlexChunk 的开发反思：为什么还没有实装？**

细心的开发者可能记得，早在 **1.2E0 版本**，我们就已经拿出了 **FlexChunk** 的原型（基于局部调色板和位存储的高效存储结构）。然而直到今天的 1.2F4，它依然没有完全实装到游戏的主逻辑中，目前游戏依然主要依赖 SimpleServerChunk 运行。  
**为什么？** 现实比我们预想的要复杂得多。  
在 1.2E0 原型阶段，我们是基于简单的**单机逻辑**思考问题的。但在 1.2F 系列转向 **C/S（客户端/服务端）架构** 后，我们发现原有的基础设施完全无法支撑 FlexChunk 的高吞吐量。

### **两大技术债务：**

1. 资源生命周期缺失 (已解决)：  
   在单机时代，加载就加载了。但在 C/S 架构下，我们需要明确的 租约 (Lease) 系统来管理谁在用这个区块、何时卸载。这我们在 1.2F2/1.2F3 中通过引入 FlexChunkLeaseService 补完了。  
2. 逻辑碎片化 (Scattered Logic)：  
   这是目前最大的拦路虎。在旧架构中，物理更新、实体 Tick、方块更新的代码散落在 ServerWorld、Entity 甚至 Chunk 类的各个角落。  
   * **风险**：这种散落的逻辑导致我们无法统一控制 FlexChunk 的执行时序。如果我们在方块更新的一半突然卸载了区块，或者在物理计算时实体跨越了未加载的区域，服务器就会崩溃。  
   * **妥协方案**：这就是为什么目前代码库中存在一堆 **"Simple"** 系列组件（如 SimpleChunkManager, SimpleEntityService）的原因。我们需要这些旧组件来维持游戏的**可启动状态**，直到新架构完全就绪。

### **未来的计划：全新的 Action 驱动器**

为了彻底解决这个问题，我们正在计划编写一个**全新的 Action 驱动逻辑**。这个新的 Action 将不再依赖旧的散落代码，而是直接驱动 FlexServerChunkService、ServerWorldPhysicsService 和 EcsEntityService 协同工作。  
在那个“新大脑”完成之前，我们将保持新旧代码共存。1.2F4 的物理与时间服务独立化，正是为了从旧逻辑中抽丝剥茧，为最终的迁移扫清障碍。  
感谢大家的耐心等待，黎明前的地基已经打好，无限世界即将到来。