# **研发日志 1.2F24：协议重塑与 Flex 时代**

大家好，  
欢迎来到 1.2F24。这是一个具有里程碑意义的版本。  
在经历了数个版本的铺垫（从 1.2E 的存储重构到 1.2F3 的服务化架构）后，我们终于完成了引擎核心最艰难的一次“换心手术”。  
在这个版本中，我们彻底重写了网络交互协议，重塑了服务端的心跳逻辑，并正式用 **Flex 区块系统** 替换了服役已久的 Simple 组件。

## **前言：Flex 区块的漫长征途——不仅是“画饼”**

细心的开发者可能记得，早在 **1.2E0 版本**，我们就已经推出了 FlexChunk 的原型。当时我们原以为它可以简单地替换掉旧的 Simple 系列组件，但现实狠狠地给我们上了一课。  
在实际调研与尝试迁移的过程中，我们发现原来的 Simple 系列架构**完全是为单人游戏设计**的。无论是区块的加载机制，还是数据的同步逻辑，都建立在“单线程、本地内存、即时响应”的假设之上。  
而 **Flex 系列区块** 是为了高性能专用服务器（Dedicated Server）而生的。这就导致了两套系统之间存在巨大的架构鸿沟。如果强行接入，服务器不仅无法享受到 Flex 的性能红利，反而会因为架构不匹配而频频崩溃。  
为了让 FlexChunk 在多人游戏环境下真正跑起来，我们必须先填补大量的辅助模块空白。回顾过去几个月的开发历程，我们实际上是在进行一场漫长的基础设施重建工程：

* **1.2E2 (服务端架构演进)**：我们将世界逻辑拆分到独立的线程 (SWEU)，为高并发区块加载打下基础。  
* **1.2E5 (地形生成器注册表)**：我们解耦了地形生成逻辑，让 FlexChunk 能够通过注册表动态选择生成算法。  
* **1.2E8 (坐标系重构)**：我们重写了坐标系统，分离了 SCA 文件坐标与内存坐标，解决了大地图下的寻址混乱。  
* **1.2E10 (状态机重构)**：我们为 FlexChunk 引入了严格的生命周期状态机 (NEW \-\> PROCESSING\_LOAD \-\> READY)，以应对异步加载中的竞态条件。  
* **1.2F2 (租约系统)**：为了解决“谁在用这个区块”的问题，我们引入了 FlexChunkLeaseService，实现了基于视口的动态资源管理。  
* **1.2F3 (服务化架构)**：我们定义了 SequenceUpdate 接口，让 ServerWorld 能够有序调度复杂的 Flex 组件。  
* **1.2F4 (时间与物理服务)**：我们将物理和时间逻辑剥离，防止它们在 FlexChunk 高负载加载时阻塞主线程。

这一连串的版本更新，实际上都是在为 FlexChunk 的登场“铺路”。我们并不是在“画饼”，而是实装 Flex 的前置工作量之巨大，远超最初的预期。  
今天，路终于铺好了。

## **一、 秩序的建立：全新的网络协议**

在旧版本中，玩家加入服务器的过程是“狂野”的：TCP 连接建立后，客户端和服务端就开始互相发送数据包，缺乏严格的状态流转控制。这经常导致“人进去了，世界还没加载”或者“世界加载了，人掉虚空里了”的尴尬情况。  
在 1.2F24 中，我们引入了一套**基于状态机（State Machine）的严格网络协议**。现在，玩家从点击“加入游戏”到真正看到画面，必须经历一套严密的“安检”流程。

### **1\. 全新的会话生命周期**

我们将 NetworkSession 的生命周期划分为以下几个不可逆的阶段：

1. **NEW (连接建立)**：  
   * TCP 连接刚刚建立。此时服务器只接受 AuthNDto（认证包）。任何其他数据包都会被视为非法，导致连接被立即切断。  
2. **AUTHORIZED (已认证)**：  
   * 服务端验证了玩家身份（UUID/数据库记录）。  
   * 在此阶段，服务端会下发 **Batch Data**（批数据），其中包含全局调色板、注册表映射等静态资源。这是确保客户端与服务端“语言互通”的关键一步。  
3. **PROCESSED (预处理完成)**：  
   * 客户端确认接收并处理完所有静态资源。此时连接处于空闲（Idle）状态，等待服务端的下一步指令。  
4. **PROCESS\_SWITCHING (进程切换中)**：  
   * 这是本版本的核心创新。当玩家需要进入一个世界（无论是首次加入还是传送），服务端会发送 PsNVo 指令，告知目标世界的参数（如 APS、时间流速）。  
   * **协商**：客户端回复 PsAllow，表示“我已经准备好接收大容量世界数据了”。  
   * **传输**：服务端开始高强度发送区块数据 (PsChunkNVo) 和实体快照 (PsPlayerNVo)。  
5. **PROCESS\_SWITCHED (切换完毕)**：  
   * 客户端接收完所有初始数据，并完成了本地资源的预加载（如网格生成）。  
   * 客户端发送 PsFinish，告诉服务端：“我准备好了，把我放进去吧。”  
6. **IN\_WORLD (游戏中)**：  
   * 服务端正式将 ServerPlayer 实体加入到 ServerWorld 中，并开始处理玩家的输入包 (PlayerInputStateNDto)。

这套流程虽然看起来繁琐，但它彻底解决了\*\*竞态条件（Race Condition）\*\*问题。玩家实体只有在客户端完全准备就绪后才会出现在世界中，彻底杜绝了“落地成盒”或“虚空跌落”的现象。

## **二、 ServerWorld Action：逻辑归位**

还记得我们在 1.2F3 中提到的 SequenceUpdate 接口吗？在 1.2F24 中，我们终于完成了最后一块拼图。

### **告别 SWEU 的“上帝循环”**

过去，ServerWorldExecutionUnit (SWEU) 是一个臃肿的“上帝类”，它不仅负责线程调度，还塞满了各种 if-else 来直接处理 Tick 逻辑。  
现在，SWEU 被彻底瘦身，它只做一件事：维持稳定的 APS (Action Per Second) 循环。

### **Action 流水线实装**

真正的逻辑现在完全托管给了 ServerWorld.action() 方法。在一个标准的 Action（帧）中，服务器会严格按照以下顺序运转：

1. **时间服务 (Time)**：推进世界时间，计算日夜更替。  
2. **事件服务 (Events)**：处理这一帧内累积的所有 GameEvent（包括网络线程异步投入的玩家输入）。  
3. **物理服务 (Physics)**：根据处理后的输入，模拟所有实体的位移、碰撞和重力。  
   * *注：我们在本版本修复了物理引擎的一个严重 Bug，确保了实体包围盒（BoundingBox）与坐标的绝对同步。*  
4. **租约服务 (Lease)**：检查区块租约的过期情况，标记需要加载或卸载的区域。  
5. **区块服务 (Chunk)**：执行实际的区块 IO 操作（加载/生成/保存）。  
6. **网络服务 (Network)**：计算玩家视口差异，将发生变化的区块和实体同步给客户端。

这种流水线设计让代码结构变得异常清晰。物理问题找 PhysicsService，同步延迟找 NetworkService，模块职责分明，互不干扰。

## **三、 Flex 区块：完全接管**

这是 1.2F24 最激动人心的变化。我们正式移除了旧版的 SimpleServerChunk 和 SimpleChunkManager。  
Flex 系列组件现在是引擎的绝对核心。

### **1\. 全栈 Flex 架构**

* **存储层**：SCA (Super Chunk Archive) \+ BitStorage。  
  * 数据以 4-bit/8-bit 的压缩格式存储在磁盘上，配合局部调色板，I/O 效率提升了数倍。  
* **逻辑层**：FlexServerChunkService。  
  * 它完美利用了 Java 的虚拟线程（Virtual Threads）和 CompletableFuture，实现了完全非阻塞的区块加载与生成。  
* **网络层**：FlexChunkSerializer。  
  * 我们在网络包中直接传输压缩后的二进制流，大幅降低了带宽占用。  
* **渲染层**：FlexClientChunk \+ FlexChunkMeshGenerator。  
  * 客户端现在使用独立的线程池异步生成网格，主线程不再因为区块加载而掉帧。

### **2\. 攻克并发难题**

Flex 的实装并非一帆风顺。在测试阶段，我们遇到了严重的 CPU 100% 占用和内存溢出问题。  
经过深入调试，我们发现这是由于网络发送逻辑中的竞态条件导致的——服务端在异步发送区块时，如果没有正确的状态保护，会导致同一个区块在一瞬间被重复序列化上千次。  
我们通过重构 NetworkSession，引入了更健壮的发送队列机制和锁机制，最终让服务端会话继承了 RpcSession 实现了IO与逻辑线程的分离，彻底解决了这个问题。现在的服务端即便面对海量的区块请求，也能保持冷静和高效。

## **结语**

1.2F24 是一个分水岭。我们不仅还清了过去积累的大量技术债务，还建立了一套工业级的网络和逻辑架构。  
现在的 OurCraft，已经拥有了一个强健的心脏（ServerWorld Action）和高效的血管（Flex Network Protocol）。  
接下来，我们将利用这套强大的系统，去构建更有趣的内容！