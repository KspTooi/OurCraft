# 1.2E_4 研发日志：玩家数据存储重构与技术债务清理

大家好，

在 1.2E_3 中，我们确立了 **Archive（归档）** 数据库与混合存储的宏伟蓝图。今天，非常高兴地宣布，这一架构中的关键一环——**玩家数据存储系统**，已经完成了从“设计”到“落地”的完整蜕变。

在本版本中，我们对旧有的玩家存档机制进行了彻底的切割与重构，正式告别了分散的 JSON 文件时代。

### 一、 彻底废弃文件式玩家存档

在过去，玩家的数据（位置、背包、状态）被保存在 `saves/players/UUID.index` 这样的 JSON 文件中，而 UUID 映射又保存在另一个 JSON 里。这种分散的结构不仅 I/O 效率低，而且在多线程环境下极易产生竞争冲突。

现在，所有的玩家数据交互已完全接管至 `ArchivePlayerManager`。
* **新玩家加入**：自动在数据库 `PLAYER_INDEX` 表中注册记录，生成 UUID，并分配安全的出生点。
* **老玩家加载**：直接从数据库毫秒级读取数据快照 (VO)。
* **离线保存**：玩家断开连接时，数据原子性地写入数据库，确保万无一失。

旧的 `SaveManager` 中关于玩家文件操作的代码已被全部移除，这标志着我们正式切断了对旧文件系统的依赖。

### 二、 精度升级：从 Float 到 Double

在迁移过程中，我们发现了一个历史遗留问题：服务端的玩家朝向（Yaw/Pitch）一直使用 `float` 存储，而数据库设计标准早已升级为 `double`。这种类型不匹配虽然微小，但在长距离传输或高精度计算中可能导致“抖动”。

本次重构中，我们顺手解决了这个技术债务：
* `ServerPlayer` 实体的 `yaw` 和 `pitch` 字段已全面升级为 `double`。
* 网络包传输层进行了相应的适配。
* 实现了内存对象 (`ServerPlayer`) 与 数据库传输对象 (`ArchivePlayerVo`) 的**零精度损失对接**。

### 三、 职责分离：实体序列化器的瘦身

之前的 `EntitySerializer` 是一个“大杂烩”，它既负责普通生物（牛、羊）的二进制序列化，又强行兼容了玩家数据的 JSON 结构逻辑。这种耦合导致代码难以维护。

既然玩家数据已经独立入库，我们对 `EntitySerializer` 进行了大幅瘦身：
* **移除了所有玩家相关的序列化逻辑**。现在的 `EntitySerializer` 专注于处理通过网络同步或区块保存的普通实体（Entity/LivingEntity）。
* 玩家不再作为“普通实体”被写入区块的实体数据流中，而是作为独立的一等公民由 `ArchiveManager` 专人专管。

### 四、 结语

1.2E_4 是一个“承上启下”的版本。表面上游戏内容没有巨大变化，但在代码层面，我们成功清理了大量历史包袱，让数据流变得清晰、纯粹。

现在，玩家数据已经安全地躺在数据库中，实体系统也轻装上阵。接下来，我们将继续推进混合存储战略的下一块拼图。

感谢大家的支持。

