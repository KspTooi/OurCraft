<h1 style="color:#883dbc;">项目经理决策</h1>

服务端的运算似乎还有问题 客户端加入以后一直收到ServerSyncEntityPositionAndRotationNVo 导致无法进行任何移动 请排查代码并制定修复计划

<h1 style="color:#ed5b00;">技术经理评估</h1>

您是对的，我们之前的修复没有从根本上解决问题。在您加入游戏时，服务器因为需要加载区块而产生延迟，导致主循环为了“追赶”进度而一次性执行了多次逻辑更新。由于网络发包的逻辑也在这个更新循环里，就向客户端发送了大量的位置同步包，造成了您描述的网络风暴。

我重新审查了架构和您提供的研发日志，并为您制定了一个全新的、更完善的修复计划。这个计划的核心是将游戏逻辑模拟和网络状态同步彻底分开。

问题根源

当前的 GameServer 主循环在追赶进度时，会多次调用 updateWorld() 方法。而 updateWorld() 不仅负责更新游戏世界的状态（如实体物理），还负责发送网络包（如玩家位置、区块更新）。这就导致在单次循环中，服务器向客户端发送了多次中间状态，引发了网络风暴。

修复计划：分离模拟与同步

我们将重构服务器的主循环，使其在追赶进度时可以多次运行模拟，但在最后只同步一次最终结果。

重构 GameServer.java

将现有的 updateWorld(float tickDelta) 方法重命名为 tick(float tickDelta)，使其明确只负责一次游戏逻辑滴答（tick）的模拟。

创建一个新的 sendNetworkUpdates() 方法，将所有发送网络包的代码（processBlockUpdates, updateDynamicViewport, sendPlayerUpdate）从 tick 方法中移至此处。

tick 方法将只保留纯粹的游戏状态计算逻辑（如处理事件、更新实体物理）。

修改 GameServer.java 的主循环 (run 方法)

主循环将继续使用时间累加器来确定需要执行多少次 tick。

在执行完所有“追赶”的 tick 之后，并且仅当至少执行过一次 tick 时，才调用一次 sendNetworkUpdates()。

这确保了无论服务器内部为了追赶进度计算了多少次，客户端在每一轮网络更新中都只会收到一份最新的、最终的游戏状态。

这个计划将彻底解决数据包风暴问题，确保服务器以稳定的频率（例如20 TPS）与客户端通信，从而消除画面闪烁和无法移动的现象。


<h1 style="color:#ed5b00;">技术经理制定研发计划</h1>


# 计划：分离服务器模拟与网络同步

为了从根本上解决由于服务器追赶逻辑（catch-up logic）而引发的网络风暴，我将对 `GameServer.java` 进行重构，分离游戏状态的模拟和网络同步。

### 1. 将世界更新逻辑分离为 `tick()` 和 `sendNetworkUpdates()`

我将把当前的 `updateWorld()` 方法拆分为两个职责单一的新方法。

**路径**: `src/main/java/com/ksptool/ourcraft/server/GameServer.java`

**a) 创建 `tick(float tickDelta)` 方法 (纯模拟)**

这个方法将只负责推进游戏世界一个步长。

```java
private void tick(float tickDelta) {
    if (world == null) {
        log.warn("GameServer: world为null，跳过本次更新");
        return;
    }

    // 1. 处理客户端发来的事件
    processEvents();
    
    // 2. 计算玩家位置，用于区块管理
    Vector3f centerPosition = new Vector3f(0, 64, 0);
    // ... (获取玩家位置的逻辑) ...
    
    // 3. 更新世界状态和所有实体的物理
    world.update(tickDelta, centerPosition, () -> {
        // ... (更新所有实体的回调逻辑) ...
        entity.update(tickDelta);
    });
}
```

**b) 创建 `sendNetworkUpdates()` 方法 (纯网络)**

这个方法将负责将当前的游戏状态同步给所有客户端。

```java
private void sendNetworkUpdates() {
    // 1. 发送方块更新
    processBlockUpdates();
    
    // 2. 发送区块加载/卸载信息
    updateDynamicViewport();
    
    // 3. 发送玩家和实体的位置信息
    sendPlayerUpdate();
}
```

### 2. 重构 `run()` 方法以使用新方法

主循环将被修改，以在追赶进度时多次调用 `tick()`，但在最后只调用一次 `sendNetworkUpdates()`。

```java
// 旧的 run() 方法将被替换

private void run() {
    log.info("GameServer主循环已启动");
    
    // ... (tickRate, tickTime, lastTime, accumulator 的初始化) ...
    
    while (running) {
        // ... (计算 deltaSeconds 和更新 accumulator) ...
        
        boolean ticked = false;
        // 运行所有需要追赶的 tick
        while (accumulator >= tickTime) {
            tick((float) tickTime);
            accumulator -= tickTime;
            ticked = true;
        }

        // 如果本轮循环至少执行过一次 tick
        if (ticked) {
            // 则在所有模拟完成后，发送一次最终的网络状态
            sendNetworkUpdates();
        }

        // ... (Thread.sleep) ...
    }
    
    log.info("GameServer主循环已停止");
}
```

通过这次重构，服务器的性能将更加稳定，即使在负载较高（如加载世界）的情况下，也能保证与客户端的通信频率是恒定的，从而彻底解决画面抖动和卡顿问题。

<h1 style="color:#883dbc;">项目经理验收</h1>

### 不通过! 有问题